#include <stdint.h>
#include <avr/interrupt.h>
#include <avr/io.h>

#include "Config.hpp"
#include "Solenoids.hpp"
#include "SolenoidTimer.hpp"

// Feedback interrupt starts/resets the timer.
// Solenoids activated at COMPA
// Solenoids deactivated at COMPB
// If overflow is reached, it's been too long since the last feedback interrupt => stop the timer.

static const uint16_t prescaler = 1024;
static const uint8_t activationLevelInt = 31;
static const uint8_t deactivationLevelInt = 84;

// static_assert((prescaler == 1)
//            || (prescaler == 8)
//            || (prescaler == 64)
//            || (prescaler == 256)
//            || (prescaler == 1024), "prescaler invalid; choices are 1, 8, 64, 256 or 1024");

static uint8_t encodePrescaler() {
  switch (prescaler) {
  case 1:
    return _BV(CS00);
  case 8:
    return _BV(CS01);
  case 64:
    return _BV(CS01) | _BV(CS00);
  case 256:
    return _BV(CS02);
  case 1024:
    return _BV(CS02) | _BV(CS00);
  default:
    // Fall back to fastest option (resulting in shortest solenoid pulse time, hence safest).
    return _BV(CS00);
  }
}

void SolenoidTimer::init() {
  // WGM0 = 000 (normal mode)
  // COM0A = 00 (OC0A output pin disabled)
  // COM1A = 00 (OC1A output pin disabled)
  TCCR0A = 0;
  // CS0 = 000 (timer disabled)
  // WGM0 = 000
  TCCR0B = 0;
  // TOIE0 = 1 (interrupt on timer overflow)
  // OCIE0A = 1 (interrupt on compare match A)
  // OCIE0B = 1 (interrupt on compare match B)
  TIMSK0 = _BV(OCIE0B) |_BV(OCIE0A) | _BV(TOIE0);
  // Compare match levels.
  OCR0A = activationLevelInt;
  OCR0B = deactivationLevelInt;
}

void SolenoidTimer::start() {
  // Ensure the timer's counter is cleared.
  TCNT0 = 0;
  // Set clock source (therefore enabling timer).
  TCCR0B = encodePrescaler();
}

void SolenoidTimer::stop() {
  TCCR0B = 0;
  Solenoids::deactivate();
}





// static uint8_t body = 200;
// static uint8_t pos = 0;
// static const uint8_t sequence[] PROGMEM = {
//   0b00001,
//   0b00010,
//   0b00100,
//   0b01000,
//   0b10000,
//   0b01000,
//   0b00100,
//   0b00010,
// };
// static bool moreDataBytes() {
//   return body > 0;
// }
// static uint8_t nextDataByte() {
//   uint8_t value = 0;
//   if (body > 0) {
//     value = pgm_read_byte(&sequence[pos]);
//     pos = (pos + 1) % 8;
//     body--;
//   }
//   return value;
// }

static uint16_t pos = 0;
static const uint8_t data[] PROGMEM = {
  // MERRY XMAS
  0x1f,
  0x02,
  0x04,
  0x02,
  0x1f,
  0x00,
  0x00,
  0x1f,
  0x15,
  0x15,
  0x11,
  0x00,
  0x00,
  0x1f,
  0x05,
  0x05,
  0x1a,
  0x00,
  0x00,
  0x1f,
  0x05,
  0x05,
  0x1a,
  0x00,
  0x00,
  0x03,
  0x1c,
  0x03,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x11,
  0x0a,
  0x04,
  0x0a,
  0x11,
  0x00,
  0x00,
  0x1f,
  0x02,
  0x04,
  0x02,
  0x1f,
  0x00,
  0x00,
  0x1e,
  0x05,
  0x05,
  0x1e,
  0x00,
  0x00,
  0x12,
  0x15,
  0x09,

  // Spacer
  0x00, 0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00, 0x00,

  // Squares
  0x15,
  0x11,
  0x12,
  0x13,
  0x1c,
  0x13,
  0x18,
  0x14,
  0x1c,
  0x10,
  0x1c,
  0x10,
  0x1c,
  0x10,
  0x11,
  0x10,
  0x10,
  0x10,
  0x10,
  0x1c,
  0x10,
  0x11,
  0x10,
  0x10,
  0x10,
  0x1c,
  0x10,
  0x11,
  0x10,
  0x10,
  0x1c,
  0x10,
  0x11,
  0x10,
  0x1c,
  0x10,
  0x11,
  0x1c,
  0x11,
  0x1c,
  0x1b,
  0x1c,
  0x0c,
  0x14,
  0x10,
  0x1c,
  0x04,
  0x1c,
  0x08,
  0x1c,
  0x02,
  0x1c,
  0x19,
  0x14,
  0x13,
  0x1c,
  0x19,
  0x13,
  0x13,
  0x1c,
  0x10,
  0x1c,
  0x0c,
  0x14,
  0x16,
  0x1c,
  0x15,
  0x16,
  0x15,
  0x1c,
  0x15,
  0x11,
  0x12,
  0x19,
  0x1c,
  0x0c,
  0x13,
  0x15,
  0x1c,
  0x15,
  0x13,
  0x14,
  0x1c,
  0x13,
  0x16,
  0x11,
  0x1c,
  0x15,
  0x14,
  0x18,
  0x1c,
  0x0c,
  0x14,
  0x17,
  0x1c,
  0x15,
  0x16,
  0x15,
  0x1c,
  0x0c,
  0x13,
  0x13,
  0x1c,
  0x0c,
  0x14,
  0x10,
  0x1c,
  0x15,
  0x13,
  0x13,
  0x1c,
  0x0c,
  0x14,
  0x18,
  0x1c,
  0x1c,
  0x13,
  0x14,
  0x1c,
  0x13,
  0x15,
  0x15,
  0x1c,
  0x0c,
  0x13,
  0x14,
  0x1c,
  0x10,
  0x1c,
  0x15,
  0x14,
  0x18,
  0x1c,
  0x15,
  0x13,
  0x13,
  0x1c,
  0x0c,
  0x15,
  0x12,
  0x1c,
  0x0c,
  0x14,
  0x1c,
  0x17,
  0x15,
  0x12,
  0x1c,
  0x1c,
  0x14,
  0x12,
  0x1c,
  0x0b,
  0x15,
  0x11,
  0x1c,
  0x0c,
  0x11,
  0x11,
  0x17,
  0x1c,
  0x15,
  0x15,
  0x12,
  0x1c,
  0x10,
  0x1c,
  0x10,
  0x1c,
  0x10,
  0x1c,
  0x10,
  0x1c,
  0x10,
  0x1c,
  0x13,
  0x11,
  0x11,
  0x10,
  0x1c,
  0x13,
  0x11,
  0x11,
  0x18,
  0x1c,
  0x10,
  0x11,
  0x10,
  0x10,
  0x1c,
  0x13,
  0x19,
  0x15,
  0x1c,
  0x19,
  0x14,
  0x11,
  0x1c,
  0x15,
  0x11,
  0x12,
  0x19,
  0x1c,
  0x19,
  0x14,
  0x14,
  0x1c,
  0x19,
  0x14,
  0x15,
  0x1c,
  0x0c,
  0x17,
  0x16,
  0x1c,
  0x0c,
  0x14,
  0x1c,
  0x17,
  0x17,
  0x16,
  0x1c,
  0x15,
  0x14,
  0x18,
  0x1c,
  0x0c,
  0x18,
  0x13,
  0x1c,
  0x15,
  0x17,
  0x15,
  0x1c,
  0x13,
  0x14,
  0x19,
  0x1c,
  0x19,
  0x14,
  0x13,
  0x1c,
  0x19,
  0x14,
  0x13,
  0x1c,
  0x05,
  0x17,
  0x16,
  0x1c,
  0x0f,
  0x17,
  0x16,
  0x1c,
  0x09,
  0x16,
  0x14,
  0x1c,
  0x09,
  0x13,
  0x12,
  0x1c,
  0x17,
  0x17,
  0x17,
  0x1c,
  0x1c,
  0x17,
  0x18,
  0x1c,
  0x15,
  0x17,
  0x19,
  0x1c,
  0x0c,
  0x17,
  0x17,
  0x1c,
  0x17,
  0x17,
  0x18,
  0x1c,
  0x15,
  0x14,
  0x18,
  0x1c,
  0x0c,
  0x18,
  0x10,
  0x1c,
  0x15,
  0x17,
  0x15,
  0x1c,
  0x13,
  0x14,
  0x19,
  0x1c,
  0x19,
  0x14,
  0x13,
  0x1c,
  0x19,
  0x14,
  0x13,
  0x1c,
  0x0c,
  0x17,
  0x19,
  0x1c,
  0x15,
  0x14,
  0x18,
  0x1c,
  0x0c,
  0x18,
  0x11,
  0x1c,
  0x15,
  0x17,
  0x15,
  0x1c,
  0x13,
  0x14,
  0x19,
  0x1c,
  0x0c,
  0x13,
  0x15,
  0x1c,
  0x0c,
  0x17,
  0x16,
  0x1c,
  0x1c,
  0x18,
  0x12,
  0x1c,
  0x0b,
  0x18,
  0x15,
  0x1c,
  0x19,
  0x14,
  0x11,
  0x1c,
  0x1d,
  0x1c,
};
static bool moreDataBytes() {
  return pos < (sizeof(data)/sizeof(data[0]));
}
static uint8_t nextDataByte() {
  return pgm_read_byte(&data[pos++]);
}

static uint8_t wait = 100;
static uint8_t lead_in = 0;
static uint8_t lead_out = 70;

ISR(TIMER0_COMPA_vect) {
  uint8_t value = 0x00;
  if (wait > 0) {
    wait--;
    return;
  }
  else if (lead_in > 0) {
    lead_in--;
  }
  else if (moreDataBytes()) {
    value = nextDataByte();
  }
  else if (lead_out > 0) {
    lead_out--;
  }
  else {
    return;
  }
  Solenoids::activate(value);
}

ISR(TIMER0_COMPB_vect) {
  Solenoids::deactivate();
}

ISR(TIMER0_OVF_vect) {
  SolenoidTimer::stop();
}
